\subsection{Concepts found}\label{subsec:concepts-found}

As a part of answering the RQ2, concepts related to UI programming and design from the found papers need to be presented.
Take note that they are often related to each other and thus difficult to separate from one another.
They cover three areas:
\begin{itemize}
    \item structure and organization of an application,
    \item definition of logic and behavior
    \item description of presentation
\end{itemize}

\subsubsection{Application structure}
This category encompasses concepts that enable modellers to describe and organize the structure of the developed application.

\paragraph{Hierarchy}
Most presented descriptions have opted for a hierarchical/tree-like structure, where each element can contain multiple \emph{children} elements and only one \emph{parent} element.

\paragraph{Application (Project)}
Given a hierarchical structure, it is necessary that it has a root node.
This role is usually fulfilled by a node called an \emph{application node} or a \emph{project node}.

\paragraph{View (Screen)}
An application consists of \emph{views}/\emph{screens} \textendash\ collections of controls that are used together in order to fulfill a certain use case.

\subparagraph{Dialog}
A \emph{dialog (window)} is a special kind of view, displayed outside the main application flow/window that can be used to display important information to a user (or receive confirmations, etc.).

\paragraph{Template}
A \emph{template} is used to describe the content of a portion of an application (a view or a component).

\paragraph{Element (Component)}
The template is made of \emph{elements}/\emph{components} \textendash\ they are the unit of a structure of a view.
The category of elements is a broad one;
it is possible to look at and classify them from multiple perspectives.

\subparagraph{Containers vs widgets}
This classification describes if the element only displays children elements and is therefore a \emph{container} or can only be used for interaction, where it can be called a \emph{widget}.

\subparagraph{Static (output) components vs dynamic (input) components}
This classification describes the level of complexity and interactivity of an element.
\emph{Static} components are only used to display information and cannot influence the application state in any way.
On the other hand, \emph{dynamic} components can handle interactions, change application state, navigate \textendash\ in general, perform actions.
A similar classification would be a split between \emph{input} components (that can accept, validate and handle data from the user) and \emph{output} components (that are used to display data from external systems).

\subparagraph{Predefined components vs custom components vs external components}
A component may be \emph{predefined} by the authors directly in the core description.
Although, from the developer's perspective, it is desirable to have a wide range of predefined components, it is often difficult and impractical for the creators of the description to enumerate them all.
Because of this, they often decide to define the most useful and popular widgets and incorporate an extension mechanism into their language.
On such mechanism is to allow for defining \emph{custom} components within the description.
Custom components are defined using features of the language and other components (be it predefined, other custom or external components).
Another example of extending the description is using \emph{external} components.
As the name suggests, they are defined outside the description \textendash\ they may come from e.g.\ existing component libraries.

\paragraph{Asset (Resource)}
An \emph{asset} describes a file that comprises the content of the interface and can be referenced by components, such as a photo, video, document, etc.

\paragraph{Modularization}
\emph{Modularization} encapsulates the possibility of splitting the description into smaller, possibly reusable parts that may be imported using a dedicated mechanism.
It is a very important capability for creating a uniform and maintainable application.

\subsubsection{Logic and behavior of application}

\paragraph{Events and handlers}
As the \emph{event}-driven paradigm is the most widespread among GUI applications, it's not surprising that practically all the languages analyzed describe the logic of the applications in similar terms.
In short, user interaction with a certain element triggers events that cause \emph{event handlers} attached to the element to be called.
Event handlers are comprised of \emph{actions} that change the state of the interface, making it interactive.

Description languages often predefine certain events, applicable to most if not all elements \textendash\ the most popular are mouse/click events (left-/right-click) and keyboard events (pressing a key or a set of keys), although many other, from more mundane (such as submit event) to more exotic (such as low device battery event) types of events exist.
Some of them also allow defining custom events, which is especially useful with custom widgets.

\paragraph{Actions}
\emph{Action} can be thought of as a unit of logic for handlers.

% Most approaches concretely define the actions that can be executed as a result of an event, e.g.\ reading or setting an attribute value, calling an external service, navigation, etc.
% \todo{unsure} It might also be possible to define custom actions as compositions of existing elemental actions.

\subparagraph{Arguments}
Arguments, just like in all programming, are a necessary construct to make functions reusable \textendash\ no wonder then, that they're also found in descriptions of UI logic.

\subparagraph{Expressions and conditions}
The languages support a simple logic by providing the possibility to reference data from arguments, other widgets and different sources, compute some arithmetic, textual or boolean expressions based on this data and deciding on the flow of actions executed in a handler.

\subparagraph{Type}
The languages usually predefine concrete actions that can be executed in the modelled applications.
Most common actions include \emph{navigation} \textendash\ moving to another screen in the application, \emph{modification of internal state} \textendash\ changing attributes of other widgets or global state, or \emph{external calls} \textendash\ calls to a server that handles business logic.


%\paragraph{Data validation and access}
%Actions and components need to be able to access some data, be it from external services or internal elements.
%This is realized through literals, variables or references.
%Additionally, the data might be transformed with the help of calculations realized by arithmetic or boolean expressions.
%
%As forms are very popular form of interaction, it's also important to be able to validate data given by users.
%Some languages also define some validators.

\paragraph{Logic of content}
Apart from making actions more expressive, logic is also useful for view/component templates.
Two of the most important tools are \emph{conditional rendering} \textendash\ displaying components based on a boolean condition and \emph{iteration} displaying components multiple times based on a list.
This topic also includes access to data in the template through \emph{interpolation}, \emph{formatting} and \emph{expressions}.

\subparagraph{Widget inputs}
To make components reusable and useful in different contexts, they may be able to accept some input parameters that ought to change their appearance or functionality.
A component can accept two types of inputs.
The first type of input is plain data \textendash\ either textual, numeric or in the form of an object \textendash\ called \emph{propositions}.
The other type is called a \emph{slot} \textendash\ this type of input accepts not only plain data, but also whole components/lists of elements;
for example, container components contain a slot for children components that ought to be displayed using a certain layout.

\paragraph{Custom component definition}
Some approaches also allow defining own, reusable stateful components.
To realize these components, some additional features beyond those described earlier are needed.

\subparagraph{Internal state}
To be able to encapsulate some logic, it is necessary to define, read and modify a state.
This is realized through \emph{variables}, \emph{fields} or \emph{properties}.

\subparagraph{Custom events}
To allow components to interact with other components, they can \emph{emit} custom \emph{events} with necessary data.

\subsubsection{Appearance and presentation}
This section is the most varied across different descriptions and at the same time feels the most underdeveloped.

\paragraph{Layout}
\emph{Layout} defines how children are laid out within a container, e.g.\ a border layout, where each element must be aligned to one of the window borders or the center of the window, or a relative layout, where elements can be aligned to other elements or the parent container.
Additionally, the layout can be further customized with properties such as separation between elements, element alignment, etc.

\subparagraph{Support for different screens and responsive layouts}
In modern UI development, it's a good practice to make interface layouts accommodate displays of different sizes and fit accordingly.
Some descriptions allow for defining some information about the display and make it available in the view to allow for more flexible components.

\paragraph{Sizing}
\emph{Sizing} allows the component to define how much space of its parent it needs to take.
There usually seem to be at least two options available: fixed size, defined in some absolute units, such as points or pixels, relative size, mostly defined as percentages.
An example of a different sizing option would be proportional sizing (where all elements indicate the proportion of the container they need to take up).

\paragraph{Positioning}
\emph{Positioning} is a complementary facet of drawing
Part of this topic overlaps with layout \textendash\ it also concerns how items are positioned.
This can happen however in two ways \textendash\ either a component tells its children how they should be laid out or the child can override or modify this setting.
Apart from the default setting, a child component can specify its position as relative to the default position or position itself absolutely.

\paragraph{Other presentation properties}
Most approaches allow for most basic styling: padding (internal separation), margins (external separation), shadow, borders, backgrounds.
Additionally, there might be support for text styling, such as font type, size, weight, decoration, etc.
Finally, it might be possible to specify the appearance of portions of applications in probably most comprehensive and robust way \textendash\ by using CSS stylesheets directly.

\subsubsection{Concepts missing}

Although the previous sections provide quite a comprehensive list of features, it is far from being complete.
It might be possible to describe a wide range of application in these simplest terms, more features are necessary to make full-fledged development of applications using these languages more feasible.
This section briefly describes the features that have not been found in any of the descriptions and which are to be found in various mobile, desktop and Web GUI technologies.

\paragraph{Specialized widgets}
As mentioned in the previous section, it is desirable for developers/modellers to work with a wide selection of components that neatly fit many possible use cases instead of developing them themselves.
Unfortunately, they might find the current state of the descriptions lacking, with only the most basic variants of components available in the descriptions.
For example, in some languages it is possible to use a grid layout;
however, none of the languages seems to have a masonry layout\footnote{Masonry layout displays content in columns, but unlike a grid, it does not require the conent to be aligned in the row axis, which makes the arrangement more balanced.} defined.

%\subparagraph{(Paged) documents}

%\paragraph{Support for touch-screens}

\paragraph{Dependency management}
As the languages are not mature and widespread, there is little incentive to create, disseminate and manage reusable pieces of UI description.
Therefore, there are not any mature mechanisms for managing any external dependencies or libraries comparable to what is available for conventional programming languages.

\paragraph{Code integration}
Currently, the languages presented are limited in their expressiveness by their limited set of actions that can be performed in response to events.
While it might be a welcome simplification for people unfamiliar with programming, it poses a grave limitation for developers.
It might be reasonable to accommodate for any gaps in the language by allowing to \enquote{patch} them with code instead.

% \subparagraph{Component lifecycle support}
% The languages could create a generic lifecycle and support it.

\paragraph{Global application state}
Most modern GUI programming enhances the event-driven paradigm with the principle of unidirectional data flow: events \enquote{flow} up (events from children components are handled by parent elements) and state \enquote{flows} down (parent components set the state of child components).
While the principle helps make the components reusable, testable and simpler to a certain extent, it fails in the case where data needs to be available throughout the application.
The response to this problem are \emph{state containers} that centralize the application state, making state management more predictable and flexible.
Future iterations of UIDLs could integrate these solutions to increase the flexibility and maintainability of developed applications.

\paragraph{Internationalization}
% \todo{chyba ze to jest w ktoryms z jezykow? idk}
Many production-grade applications require to be available in more than one language version.
However, to generate multiple versions of an applications, each using a different language would be impractical;
instead, any locale-dependent resources (primarily text) are stored outside application code and loaded during runtime, depending on the language set by the user/system.
Integrating such a mechanism directly into the language would increase the value and flexibility of languages.

% \paragraph{Accessibility} \todo{not really sure that's a single feature that can be easily included}

\paragraph{Animations}
While it is possible to create full-scale applications without any animations, they can still make a big difference and transform a satisfactory user experience to an outstanding one.
Animations are useful for indicating navigation, interaction progress and state changes in a friendly and visually appealing way.
Without this feature in UIDLs, generated applications might miss out on this subtle aspect of user experience.

\paragraph{Design systems}
Design systems have emerged as a solution easing the development of various applications across multiple teams by establishing clear and common rules and style guides, defining reusable patterns and components.
By using them, organizations and companies can spend less time designing and implementing their applications, while achieving reliability and a unified appearance across all their products.
So far, there seems to be no explicit support for defining any parts of a style guide in the UIDLs analyzed which make them less suitable for large-scale development.

\paragraph{Dynamic appearance}
% todo: 4 sure?
Additionally, any support for making the appearance of some UI elements dependent on component/application state also seems to be largely absent.
The most important application for such a feature would be implementation of application themes (especially the famous dark theme).
This further prevents developers from implementing more engaging interactions and customizable experiences.
