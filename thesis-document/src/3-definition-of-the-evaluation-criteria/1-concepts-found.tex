\subsection{Concepts found}\label{subsec:concepts-found}

As a part of answering the RQ2, concepts related to UI programming and design from the found papers need to be presented.
Take note that they are often related to each other and thus difficult to separate from one another.
They cover three areas:
\begin{itemize}
    \item structure and organization of an application,
    \item definition of logic and behavior
    \item description of presentation
\end{itemize}

\subsubsection{Application structure}
This category encompasses concepts that enable modellers to describe and organize the structure of the developed application.

\paragraph{Hierarchy}
Most presented descriptions have opted for a hierarchical/tree-like structure, where each element can contain multiple \emph{children} elements and only one \emph{parent} element.

\paragraph{Application (Project)}
Given a hierarchical structure, it is necessary that it has a root node.
This role is usually fulfilled by a node called an \emph{application node} or a \emph{project node}.

\paragraph{View (Screen)}
An application consists of \emph{views}/\emph{screens} \textendash\ collections of controls that are used together in order to fulfill a certain use case.

\subparagraph{Dialog}
A \emph{dialog (window)} is a special kind of view, displayed outside the main application flow/window that can be used to display important information to a user (or receive confirmations, etc.).

\paragraph{Template}
A \emph{template} is used to describe the content of a portion of an application (a view or a component).

\paragraph{Element (Component)}
The template is made of \emph{elements}/\emph{components} \textendash\ they are the unit of a structure of a view.
The category of elements is a broad one;
it is possible to look at and classify them from multiple perspectives.

\subparagraph{Containers vs widgets}
This classification describes if the element only displays children elements and is therefore a \emph{container} or can only be used for interaction, where it can be called a \emph{widget}.

\subparagraph{Static (output) components vs dynamic (input) components}
This classification describes the level of complexity and interactivity of an element.
\emph{Static} components are only used to display information and cannot influence the application state in any way.
On the other hand, \emph{dynamic} components can handle interactions, change application state, navigate \textendash\ in general, perform actions.
A similar classification would be a split between \emph{input} components (that can accept, validate and handle data from the user) and \emph{output} components (that are used to display data from external systems).

\subparagraph{Predefined components vs custom components vs external components}
A component may be \emph{predefined} by the authors directly in the core description.
Although, from the developer's perspective, it is desirable to have a wide range of predefined components, it is often difficult and impractical for the creators of the description to enumerate them all.
Because of this, they often decide to define the most useful and popular widgets and incorporate an extension mechanism into their language.
\todo[inline]{finish him!}
A \emph{custom} component is one that's built from existing ones within the description.
An \emph{external} component is, as the name suggests, defined outside the description, but should be taken into consideration while generating final code.

\paragraph{Asset (Resource)}
An \emph{asset} describes a file that comprises the content of the interface and can be referenced by components, such as a photo, video, document, etc.

\paragraph{Modularization}
\emph{Modularization} encapsulates the possibility of splitting the description into smaller, possibly reusable parts that may be imported using a dedicated mechanism.
It is a very important capability for creating a uniform and maintainable application.

\subsubsection{Logic and behavior of application}

\paragraph{Events and handlers}
As the \emph{event}-driven paradigm is the most widespread among GUI applications, it's not surprising that practically all the languages analyzed describe the logic of the applications in similar terms.
In short, user interaction with a certain element triggers events that cause \emph{event handlers} attached to the element to be called.
Event handlers are comprised of \emph{actions} that change the state of the interface, making it interactive.

Description languages often predefine certain events, applicable to most if not all elements \textendash\ the most popular are mouse/click events (left-/right-click) and keyboard events (pressing a key or a set of keys), although many other, from more mundane (such as submit event) to more exotic (such as low device battery event) types of events exist.
Some of them also allow defining custom events, which is especially useful with custom widgets.

\paragraph{Actions}
\emph{Action} can be thought of as a unit of logic for handlers.

% Most approaches concretely define the actions that can be executed as a result of an event, e.g.\ reading or setting an attribute value, calling an external service, navigation, etc.
% \todo{unsure} It might also be possible to define custom actions as compositions of existing elemental actions.

\subparagraph{Arguments}
Arguments, just like in all programming, are a necessary construct to make functions reusable \textendash\ no wonder then, that they're also found in descriptions of UI logic.

\subparagraph{Expressions and conditions}
The languages support a simple logic by providing the possibility to reference data from arguments, other widgets and different sources, compute some arithmetic, textual or boolean expressions based on this data and deciding on the flow of actions executed in a handler.

\subparagraph{Type}
The languages usually predefine concrete actions that can be executed in the modelled applications.
Most common actions include \emph{navigation} \textendash\ moving to another screen in the application, \emph{modification of internal state} \textendash\ changing attributes of other widgets or global state, or \emph{external calls} \textendash\ calls to a server that handles business logic.


%\paragraph{Data validation and access}
%Actions and components need to be able to access some data, be it from external services or internal elements.
%This is realized through literals, variables or references.
%Additionally, the data might be transformed with the help of calculations realized by arithmetic or boolean expressions.
%
%As forms are very popular form of interaction, it's also important to be able to validate data given by users.
%Some languages also define some validators.

\paragraph{Logic of content}
Apart from making actions more expressive, logic is also useful for view/component templates.
Two of the most important tools are \emph{conditional rendering} \textendash\ displaying components based on a boolean condition and \emph{iteration} displaying components multiple times based on a list.
This topic also includes access to data in the template through \emph{interpolation}, \emph{formatting} and \emph{expressions}.

\subparagraph{Widget inputs}
To make components reusable and useful in different contexts, they may be able to accept some input parameters that ought to change their appearance or functionality.
A component can accept two types of inputs.
The first type of input is plain data \textendash\ either textual, numeric or in the form of an object \textendash\ called \emph{propositions}.
The other type is called a \emph{slot} \textendash\ this type of input accepts not only plain data, but also whole components/lists of elements;
for example, container components contain a slot for children components that ought to be displayed using a certain layout.

\paragraph{Custom component definition}
Some approaches also allow defining own, reusable stateful components.
To realize these components, some additional features beyond those described earlier are needed.

\subparagraph{Internal state}
To be able to encapsulate some logic, it is necessary to define, read and modify a state.
This is realized through \emph{variables}, \emph{fields} or \emph{properties}.

\subparagraph{Custom events}
To allow components to interact with other components, they can \emph{emit} custom \emph{events} with necessary data.

\subsubsection{Appearance and presentation}
This section is the most varied across different descriptions and at the same time feels the most underdeveloped.

\paragraph{Layout}
\emph{Layout} defines how children are laid out within a container, e.g.\ a border layout, where each element must be aligned to one of the window borders or the center of the window, or a relative layout, where elements can be aligned to other elements or the parent container.
Additionally, the layout can be further customized with properties such as separation between elements, element alignment, etc.

\paragraph{Sizing}
\emph{Sizing} allows the component to define how much space of its parent it needs to take.
There usually seem to be at least two options available: fixed size, defined in some absolute units, such as points or pixels, relative size, mostly defined as percentages.
An example of a different sizing option would be proportional sizing (where all elements indicate the proportion of the container they need to take up).

\paragraph{Positioning}
\emph{Positioning} is a complementary facet of drawing
Part of this topic overlaps with layout \textendash\ it also concerns how items are positioned.
This can happen however in two ways \textendash\ either a component tells its children how they should be laid out or the child can override or modify this setting.
Apart from the default setting, a child component can specify its position as relative to the default position or position itself absolutely.

\paragraph{Support for different screens and responsive layouts}
In modern UI development, it's a good practice to make interface layouts accommodate displays of different sizes and fit accordingly.
Some descriptions allow for defining some information about the display and make it available in the view to allow for more flexible components.

\paragraph{Other presentation properties}

Most approaches allow for most basic styling: padding (internal separation), margins (external separation), shadow, borders, backgrounds.
Additionally, there might be support for text styling, such as font type, size, weight, decoration, etc.
Finally, it might be possible to specify the appearance of portions of applications in probably most comprehensive and robust way \textendash\ by using CSS stylesheets directly.
