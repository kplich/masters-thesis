\subsection{Evaluation criteria}\label{subsec:evaluation-criteria}

This section lists concepts related to programming user interfaces that were included in the selected papers.
The definitions were formulated by the author through relating the concepts described in the papers with concepts found in actual GUI technologies.
They criteria three areas covered in subsequent subsections: architecture and basic elements, logic and behavior, and appearance and presentation details.

\subsubsection{GUI architecture and basic elements}
This category encompasses concepts that enable modellers to describe and organize the structure of the developed application.

\paragraph{Hierarchical description of UI structure and content}
Most presented descriptions describe the structure and contents of GUIs using hierarchical/tree-like structures, where each element can contain multiple \emph{children} elements and only one \emph{parent} element.
The choice reflects the structure of descriptions used by many final UI technologies (\todo{add footnote for HTML}HTML, Android XML\furl{https://developer.android.com/guide/topics/resources/layout-resource}, XAML\furl{https://learn.microsoft.com/en-us/dotnet/desktop/wpf/xaml/}, FXML\furl{https://docs.oracle.com/javase/8/javafx/api/javafx/fxml/doc-files/introduction_to_fxml.html})
The root node of such a structure is often highlighted in the descriptions and named an \textbf{application node} or a \textbf{project node}.

\paragraph{View}
An application consists of \emph{views}/\emph{screens} \textendash\ collections of controls that are used together in order to fulfill a certain use case.
The closest real-world analogue would be an Android \texttt{Activity}\furl{https://developer.android.com/reference/android/app/Activity}, representing \enquote{a single, focused thing that the user can do.}
A special kind of view is a \textbf{dialog (window)}.
It is displayed outside the main flow of the GUI (mostly above) that can be used to display important information to a user (or receive confirmations, etc.).
The concept is realized e.g.\ in the \texttt{dialog}\furl{https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dialog} defined in the HTML5 language.

\paragraph{Element (Component)}
The template is made of \emph{elements}/\emph{components} \textendash\ they are the unit of a structure of a view.
The category of elements is a broad one;
it is possible to look at and classify them from multiple perspectives.

\subparagraph{Containers vs widgets}
This classification describes if the element can contain and handle children components \textendash\ in that case, it is called a \emph{container}.
Otherwise, when it is meant to be used on its own, it is called a \emph{widget}.
Most UI elements can be classified as widgets, e.g.\ buttons, form fields, multimedia, etc.
However, container components have an important role in the UI, grouping related elements together and providing a usable structure to the interface.
Examples of container components include lists, cards\furl{https://material.angular.io/components/card/overview}, and layout components (e.g.\ grid\furl{https://mui.com/material-ui/react-grid/} or relative\furl{https://learn.microsoft.com/en-us/windows/apps/design/layout/layout-panels\#relativepanel}).
The classification does not have to be binary \textendash\ for example, a tabbed layout\furl{https://developer.apple.com/documentation/appkit/nstabview\#2555818} contains other content, but also has its own controls responsible for switching tabs.

\subparagraph{Output vs input components}
This classification describes whether components enable interactivity of the GUI (can be used to provide data or change application state).
\emph{Output} components are only used to display information and do not let the user change application state in any way.
Examples of output components could be text elements, labels, multimedia components and container components.
On the other hand, \emph{input} components allow user to interact with the application, e.g.\ by providing data using input fields or triggering any changes in application state.

\subparagraph{Predefined components vs custom components vs external components}
A component may be \emph{predefined} by the authors directly in the core description.
Although, from the developer's perspective, it is desirable to have a wide range of predefined components, it is often difficult and impractical for the creators of the description to enumerate them all.
Because of this, they often decide to define the most useful and popular widgets and incorporate an extension mechanism into their language.
On such mechanism is to allow for defining \emph{custom} components within the description.
Custom components are defined using features of the language and other components (be it predefined, other custom or external components).
Another example of extending the description is using \emph{external} components.
As the name suggests, they are defined outside the description \textendash\ they may come from e.g.\ existing component libraries.

The fitting analogy is the relationship between HTML, Web Components\furl{https://developer.mozilla.org/en-US/docs/Web/API/Web_Components} and client-side JavaScript frameworks\furl{https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/Introduction}.
HTML defines a set of \emph{predefined} elements useful for describing documents.
Client-side frameworks provide mechanisms to use these elements to create \emph{custom} components that fulfill application-specific needs.
However, to speed up development time, both HTML and frameworks may want to reuse \emph{external} components developed by third parties \textendash\ Web Components allow developers to use them directly in HTML\@.

\paragraph{Asset (Resource)}
\emph{Assets} or a \emph{resources} are files that are used by the application for various purposes.
\todo{rephrase}Android applications can contain resources for different purposes: from more usual, such as graphical and font files, to more unexpected, such as configuration and binary files.

\paragraph{Modularization}
\todo[inline]{think about it, is this necessary? well, this is obvious in programming languages, but can be less so in abstract description languages}
\emph{Modularization} encapsulates the possibility of splitting the description into smaller, possibly reusable parts that may be imported using a dedicated mechanism.
It is a very important capability for creating a uniform and maintainable application.

\subsubsection{Logic and behavior of application}

\paragraph{Events and handlers}
As the \emph{event}-driven paradigm is the most widespread among GUI applications, it's not surprising that practically all the languages analyzed describe the logic of the applications in similar terms.
In short, user interaction with a certain element triggers events that cause \emph{event handlers} attached to the element to be called.
Event handlers are comprised of \emph{actions} that change the state of the interface, making it interactive.

Description languages often predefine certain events, applicable to most if not all elements \textendash\ the most popular are mouse/click events (left-/right-click) and keyboard events (pressing a key or a set of keys), although many other, from more mundane (such as submit event) to more exotic (such as low device battery event) types of events exist.
Some of them also allow defining custom events, which is especially useful with custom widgets.

\paragraph{Actions}
\emph{Action} can be thought of as a unit of logic for handlers.

% Most approaches concretely define the actions that can be executed as a result of an event, e.g.\ reading or setting an attribute value, calling an external service, navigation, etc.
% \todo{unsure} It might also be possible to define custom actions as compositions of existing elemental actions.

\subparagraph{Arguments}
Arguments, just like in all programming, are a necessary construct to make functions reusable \textendash\ no wonder then, that they're also found in descriptions of UI logic.

\subparagraph{Expressions and conditions}
The languages support a simple logic by providing the possibility to reference data from arguments, other widgets and different sources, compute some arithmetic, textual or boolean expressions based on this data and deciding on the flow of actions executed in a handler.

\subparagraph{Type}
The languages usually predefine concrete actions that can be executed in the modelled applications.
Most common actions include \emph{navigation} \textendash\ moving to another screen in the application, \emph{modification of internal state} \textendash\ changing attributes of other widgets or global state, or \emph{external calls} \textendash\ calls to a server that handles business logic.


%\paragraph{Data validation and access}
%Actions and components need to be able to access some data, be it from external services or internal elements.
%This is realized through literals, variables or references.
%Additionally, the data might be transformed with the help of calculations realized by arithmetic or boolean expressions.
%
%As forms are very popular form of interaction, it's also important to be able to validate data given by users.
%Some languages also define some validators.

\paragraph{Logic of content}
Apart from making actions more expressive, logic is also useful for view/component templates.
Two of the most important tools are \emph{conditional rendering} \textendash\ displaying components based on a boolean condition and \emph{iteration} displaying components multiple times based on a list.
This topic also includes access to data in the template through \emph{interpolation}, \emph{formatting} and \emph{expressions}.

\subparagraph{Widget inputs}
To make components reusable and useful in different contexts, they may be able to accept some input parameters that ought to change their appearance or functionality.
A component can accept two types of inputs.
The first type of input is plain data \textendash\ either textual, numeric or in the form of an object \textendash\ called \emph{propositions}.
The other type is called a \emph{slot} \textendash\ this type of input accepts not only plain data, but also whole components/lists of elements;
for example, container components contain a slot for children components that ought to be displayed using a certain layout.

\paragraph{Custom component definition}
Some approaches also allow defining own, reusable stateful components.
To realize these components, some additional features beyond those described earlier are needed.

\subparagraph{Internal state}
To be able to encapsulate some logic, it is necessary to define, read and modify a state.
This is realized through \emph{variables}, \emph{fields} or \emph{properties}.

\subparagraph{Custom events}
To allow components to interact with other components, they can \emph{emit} custom \emph{events} with necessary data.

\subsubsection{Appearance and presentation}
This section is the most varied across different descriptions and at the same time feels the most underdeveloped.

\paragraph{Layout}
\todo[inline]{this can often be realized as a component, too!}
\emph{Layout} defines how children are laid out within a container, e.g.\ a border layout, where each element must be aligned to one of the window borders or the center of the window, or a relative layout, where elements can be aligned to other elements or the parent container.
Additionally, the layout can be further customized with properties such as separation between elements, element alignment, etc.

\subparagraph{Support for different screens and responsive layouts}
In modern UI development, it's a good practice to make interface layouts accommodate displays of different sizes and fit accordingly.
Some descriptions allow for defining some information about the display and make it available in the view to allow for more flexible components.

\paragraph{Sizing}
\emph{Sizing} allows the component to define how much space of its parent it needs to take.
There usually seem to be at least two options available: fixed size, defined in some absolute units, such as points or pixels, relative size, mostly defined as percentages.
An example of a different sizing option would be proportional sizing (where all elements indicate the proportion of the container they need to take up).

\paragraph{Positioning}
\emph{Positioning} is a complementary facet of drawing
Part of this topic overlaps with layout \textendash\ it also concerns how items are positioned.
This can happen however in two ways \textendash\ either a component tells its children how they should be laid out or the child can override or modify this setting.
Apart from the default setting, a child component can specify its position as relative to the default position or position itself absolutely.

\paragraph{Other presentation properties}
Most approaches allow for most basic styling: padding (internal separation), margins (external separation), shadow, borders, backgrounds.
Additionally, there might be support for text styling, such as font type, size, weight, decoration, etc.
Finally, it might be possible to specify the appearance of portions of applications in probably most comprehensive and robust way \textendash\ by using CSS stylesheets directly.
