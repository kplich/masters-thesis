\subsection{Evaluation criteria}\label{subsec:evaluation-criteria}

This section lists concepts related to programming user interfaces that were included in the selected papers.
The definitions were formulated by the author through relating the concepts described in the papers with concepts found in actual GUI technologies.
They criteria three areas covered in subsequent subsections: architecture and basic elements, logic and behavior, and appearance and presentation details.

\subsubsection{GUI architecture and basic elements}
This category encompasses concepts that enable modellers to describe and organize the structure of the developed application.

\paragraph{Hierarchical description of UI structure and content}
Most presented descriptions describe the structure and contents of GUIs using hierarchical/tree-like structures, where each element can contain multiple \emph{children} elements and only one \emph{parent} element.
The choice reflects the structure of descriptions used by many final UI technologies (HTML\furl{https://developer.mozilla.org/en-US/docs/Learn/HTML/Introduction_to_HTML/Getting_started\#nesting_elements}, Android XML\furl{https://developer.android.com/guide/topics/resources/layout-resource}, XAML\furl{https://learn.microsoft.com/en-us/dotnet/desktop/wpf/xaml/}, FXML\furl{https://docs.oracle.com/javase/8/javafx/api/javafx/fxml/doc-files/introduction_to_fxml.html})
The root node of such a structure is often highlighted in the descriptions and named an \emph{application node} or a \emph{project node}.

\paragraph{View}
An application consists of \emph{views}/\emph{screens} \textendash\ collections of controls that are used together in order to fulfill a certain use case.
The closest real-world analogue would be an Android \texttt{Activity}\furl{https://developer.android.com/reference/android/app/Activity}, representing \enquote{a single, focused thing that the user can do.}
A special kind of view is a \emph{dialog (window)}.
It is displayed outside the main flow of the GUI (mostly above) that can be used to display important information to a user (or receive confirmations, etc.).
The concept is realized e.g.\ in the \texttt{<dialog>} element\furl{https://developer.mozilla.org/en-US/docs/Web/HTML/Element/dialog} defined in the HTML language.

\paragraph{Component (element)}
The template is made of \emph{elements}/\emph{components} \textendash\ they are the smallest parts of a description of a view.
The category of components is broad;
it is possible to look at and classify them from multiple perspectives.
\todo[inline]{no subparagraphs, just items in a list? not sure here, though}

\subparagraph{Containers vs widgets}
This classification describes if the element can contain and handle children components \textendash\ in that case, it is called a \emph{container}.
Otherwise, when it is meant to be used on its own, it is called a \emph{widget}.
Most UI elements can be classified as widgets, e.g.\ buttons, form fields, multimedia, etc.
However, container components have an important role in the UI, grouping related elements together and providing a usable structure to the interface.
Examples of container components include lists, cards\furl{https://material.angular.io/components/card/overview}, and layout components (e.g.\ grid\furl{https://mui.com/material-ui/react-grid/} or relative\furl{https://learn.microsoft.com/en-us/windows/apps/design/layout/layout-panels\#relativepanel}).
The classification does not have to be binary \textendash\ for example, a tabbed layout\furl{https://developer.apple.com/documentation/appkit/nstabview\#2555818} contains other content, but also has its own controls responsible for switching tabs.

\subparagraph{Output vs input components}
This classification describes whether components enable interactivity of the GUI (can be used to provide data or change application state).
\emph{Output} components are only used to display information and do not let the user change application state in any way.
Examples of output components could be text elements, labels, multimedia components and container components.
On the other hand, \emph{input} components allow user to interact with the application, e.g.\ by providing data using input fields or triggering any changes in application state.

\subparagraph{Predefined components vs custom components vs external components}
A component may be \emph{predefined} by the authors directly in the core description.
Although, from the developer's perspective, it is desirable to have a wide range of predefined components, it is often difficult and impractical for the creators of the description to enumerate them all.
Because of this, they often decide to define the most useful and popular widgets and incorporate an extension mechanism into their language.
One such mechanism is to allow for defining \emph{custom} components within the description.
Custom components are defined using features of the language and other components (be it predefined, other custom or external components).
Another example of extending the description is using \emph{external} components.
As the name suggests, they are defined outside the description \textendash\ they may come from e.g.\ existing component libraries.

The fitting analogy is the relationship between HTML, Web Components\furl{https://developer.mozilla.org/en-US/docs/Web/API/Web_Components} and client-side JavaScript frameworks\furl{https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/Introduction}.
HTML defines a set of \emph{predefined} elements useful for describing documents.
Client-side frameworks provide mechanisms to use these elements to create \emph{custom} components that fulfill application-specific needs.
However, to speed up development time, both HTML and frameworks may want to reuse \emph{external} components developed by third parties \textendash\ Web Components allow developers to use them directly in HTML\@.

\paragraph{Asset (Resource)}
\emph{Assets} or \emph{resources} are files that are used by the application for various purposes.
As an example, Android applications can contain resources that can be used in different contexts, e.g.\ fonts, configuration files and binary files\furl{https://developer.android.com/guide/topics/resources/providing-resources}.

\paragraph{Modularization}
\emph{Modularization} encapsulates the possibility of splitting the description into smaller, possibly reusable parts (preferably across multiple files) that may be imported.
Because of its importance for creating uniform and maintainable applications, this capability is a strict necessity in standard programming languages;
however, not all UIDLs provide such a possibility.

\subsubsection{Logic and behavior of application}

This category comprises concepts that allow modellers to make the UI interactive.

\paragraph{Events and handlers}
As the \emph{event}-driven paradigm is the standard among GUI applications~\cite{wang2016event}, it's not surprising that practically all the languages analyzed describe the logic of user interfaces in similar terms.
In short, user interaction with a certain element triggers events that cause \emph{event handlers} attached to the element to be called.
Event handlers are comprised of \emph{actions} that change the state of the interface, making it interactive.
This mechanism is used the most extensively in client-side Web frameworks\furl{https://vuejs.org/guide/essentials/component-basics.html\#listening-to-events}\furl{https://angular.io/guide/event-binding}.

Description languages (similarly to final technologies) often predefine certain events, applicable to most elements \textendash\ the most popular are mouse events (e.g.\ a \emph{left-}/\emph{right click}) and keyboard events (e.g.\ pressing a key or a set of keys), although many other types of events could exist\furl{https://developer.mozilla.org/en-US/docs/Web/Events}.
Additionally, some description languages also allow defining custom events, which is especially useful with custom widgets.

\paragraph{Actions}
\emph{Action} can be thought of as a unit of logic for handlers.
They represent everything what in final UI technologies is usually achieved with code.
\todo[inline]{subconcepts in a list, not subparagraphs}

% Most approaches concretely define the actions that can be executed as a result of an event, e.g.\ reading or setting an attribute value, calling an external service, navigation, etc.
% \todo{unsure} It might also be possible to define custom actions as compositions of existing elemental actions.

\subparagraph{Arguments}
Arguments, just like in all programming, are a necessary construct to make functions reusable \textendash\ no wonder then, that they're also found in descriptions of UI logic.

\subparagraph{Expressions and conditions}
The languages usually support simple logic by providing the possibility to reference data from arguments, other widgets and different sources, compute some arithmetic, textual or boolean expressions based on this data and deciding on the flow of actions executed in a handler.

\subparagraph{Type}
The languages usually predefine concrete actions that can be executed in the modelled applications.
Most common actions include \emph{navigation} \textendash\ moving to another screen in the application, \emph{modification of internal state} \textendash\ changing attributes of other widgets or global state, or \emph{external calls} \textendash\ calls to a server that handles business logic.


%\paragraph{Data validation and access}
%Actions and components need to be able to access some data, be it from external services or internal elements.
%This is realized through literals, variables or references.
%Additionally, the data might be transformed with the help of calculations realized by arithmetic or boolean expressions.
%
%As forms are very popular form of interaction, it's also important to be able to validate data given by users.
%Some languages also define some validators.

\paragraph{Logic of content}
Apart from making actions more expressive, logic is also useful for defining the content of views/components.
Two of the most important tools are \emph{conditional rendering} \textendash\ displaying components based on a boolean condition and \emph{iteration} displaying components multiple times based on a list.
Some representations also include a mechanism, which allows for including variables and expressions within the description of the content of an element.
In technologies where component content is not described using code, this is achieved through \emph{interpolation}\furl{https://angular.io/guide/interpolation} \textendash\ replacing the variables or expressions in a string/template with their values.

\subparagraph{Widget input parameters}
\todo[inline]{incorporate into paragraph or make its own}
To make components reusable and useful in different contexts, they may be able to accept some input parameters.
One type of input parameters allows for configuring the components and changing their appearance or functionality \textendash\ these parameters can be called \emph{attributes}.
In many XML-based languages, properties are passed as attributes\furl{https://developer.mozilla.org/en-US/docs/Learn/HTML/Introduction_to_HTML/Getting_started\#attributes}\furl{https://learn.microsoft.com/en-us/dotnet/desktop/wpf/xaml/?view=netdesktop-7.0\#attribute-syntax-properties}.
Client-side Web frameworks additionally use an additional mechanism (alongside HTML attributes) for passing data to components, called \emph{props}\furl{https://vuejs.org/guide/essentials/component-basics.html\#passing-props} (short for \enquote{properties}).
The other type of input allows for defining the content of components.
In XML-based languages, for example, this typically happens by simply nesting elements\furl{https://developer.mozilla.org/en-US/docs/Learn/HTML/Introduction_to_HTML/Getting_started\#nesting_elements}.

\paragraph{Custom component definition}
Some approaches also allow defining own, reusable stateful components.
To realize these components, some additional features beyond those described earlier are needed.
\todo[inline]{which ones exactly described earlier are necessary?}
\todo[inline]{features in a list, not subparagraphs}

\subparagraph{Internal state}
To be able to encapsulate some logic, it is necessary to define, read and modify a state.
This is realized through \emph{variables}, \emph{fields} or \emph{properties}.

\subparagraph{Custom events}
To allow components to interact with other components, they can \emph{emit} custom \emph{events} with necessary data.

\subsubsection{Appearance}
This category describes concepts that give developers influence over the appearance of the GUI\@.

\paragraph{Layout}
\emph{Layout} defines how children are laid out within a container, e.g.\ a border layout, where each element must be aligned to one of the window borders or the center of the window, or a relative layout, where elements can be aligned to other elements or the parent container.
Additionally, the layout can be further customized with properties such as separation between elements, element alignment, etc.

Usually, layout is implemented through a dedicated container component that is responsible for placing its children\furl{https://learn.microsoft.com/en-us/windows/apps/design/layout/layout-panels}.
However, in the Web stack, layout is defined in the presentation layer using CSS properties\furl{https://developer.mozilla.org/en-US/docs/Web/CSS/display}.

\subparagraph{Support for different screens and responsive layouts}
\todo[inline]{make this a list or incorporate in the previous paragraph}
In modern UI development, it's a good practice to make interface layouts accommodate displays of different sizes and fit accordingly.
Some descriptions allow for defining some information about the display and make it available in the view to allow for more flexible components.

\paragraph{Sizing}
\emph{Sizing} allows the component to define how much space of its parent it needs to take.
There usually seem to be at least two options available: fixed size, defined in some absolute units, such as points or pixels, relative size, mostly defined as percentages.
An example of a different sizing option would be proportional sizing (where all elements indicate the proportion of the container they need to take up).

\paragraph{Positioning}
\emph{Positioning} is a complementary facet of sizing.
Part of this topic overlaps with layout \textendash\ it also concerns how items are positioned.
This can happen however in two ways \textendash\ either a component tells its children how they should be laid out or the child can override or modify this setting.
Apart from the default setting, a child component can specify its position as relative to the default position or position itself absolutely.

\paragraph{Other presentation properties}
Most approaches allow for most basic styling: padding (internal separation), margins (external separation), shadow, borders, backgrounds.
Additionally, there might be support for text styling, such as font type, size, weight, decoration, etc.
Finally, some descriptions make it possible to specify the appearance of portions of applications in probably most comprehensive and robust way \textendash\ by using CSS directly.
