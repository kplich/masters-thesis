\subsubsection{RQ 1}\label{subsubsec:rq-1}

This section presents the results of the literature review.
The selected papers have been reviewed and compared.
Any additional relevant sources that they referenced were taken into account.
The papers have been grouped into four categories, depending on what kind of approach they presented.
The analysis resulted in a definition of a set of evaluation criteria against which the papers have been judged.
After the evaluation, a textual summary capturing additional aspects of reviewed papers has been written.
Finally, each category of papers has been summarized to highlight similarities between works within it and distinctions between works in other categories.

The four groups of approaches presented are: UML meta-models, declarative approaches (including domain specific languages\,\textemdash\,DSLs), user interface description languages (UIDLs) and ontologies.
However, the distinction between these categories need not always be clear.
For example, it is often the case that a language is defined on the basis of a UML meta-model (e.g.\ as in~\cite{Karu2013-po} or~\cite{moldovan2020open}).
Additionally, the difference between a DSL and a UIDL does not have to be obvious\,\textemdash\,both are formal, textual representations of a model.
The deciding factor could be their intended usage: DSLs tend to have more readable syntax which allows developers to use the languages directly;
UIDLs, on the other hand, are intended to be parsed and processed by machines\,\textemdash\,to work comfortably with them, people should use dedicated tools.

\paragraph{The Cameleon Framework}

The Cameleon Reference Framework (CRF)~\cite{calvary_cameleon_framework_2002, calvary_cameleon_glossary_2002} represents an important development in the field of model-based UI development.
It defines and organizes many aspects of development of multi-target UIs\footnote{UIs for multiple types of users, platforms and environments} into a framework for evaluation of tools and approaches related to the discipline.
The main takeaway, necessary for understanding the evaluation criterion (as well as the field of MBUID in general), is that the framework recommends modelling the UIs in four stages (ordered from the most to the least abstract):
\begin{itemize}
    \item \textbf{tasks and concepts (T+C)}: the UI is viewed only from a \textbf{functional and conceptual perspective};
          practically no thought is given to specifics of the interaction
%    \begin{itemize}
%        \item task: A goal, together with some procedure or set of actions that will achieve the goal~\cite{calvary_cameleon_glossary_2002}.
%        \item concept: anything relevant to the user that helps them accomplish tasks in the domain
%    \end{itemize}
    \item \textbf{abstract UI (AUI)}: the UI is structured \textbf{independently from modality}\,\textemdash\,there might be talk of \emph{multiple selection} but it's not yet known whether it'll be realized through e.g.\ voice, a telephone keyboard, or a touchscreen)
    \item \textbf{concrete UI (CUI)}: the modality of the UI is known and the specification is only \textbf{independent from technology};
          e.g.\ the definition assumes a graphical UI and specifies a text input\,\textemdash\,however, it's not yet decided, what toolkit (e.g.\ C++ with Qt, Java with Swing/JavaFX or HTML with JS) will be used to realize it
    \item \textbf{final UI (FUI)}: the executable UI, written in a \textbf{particular technology} with its distinct \emph{look and feel}.
\end{itemize}

Models at these stages can be related to one another through transformations: \emph{abstraction}, \emph{reification} and \emph{translation}.
For example, the AUI stage \emph{abstracts} the CUI stage\,\textemdash\,the modality-specific information is lost (can't be expressed) at this stage.
On the other hand, the AUI stage \emph{reifies} the T+C stage by adding more information about how the UI should be structured.
These two are complemented by translation\,\textemdash\,a transformation between models at the same stage (e.g.\ AUI models for different modalities.)

\paragraph{Evaluation criteria}

Introduction of the CRF provides the context that can help better understand the evaluation criteria of the review.
The following set is been chosen as a result of comparing the previously selected papers.
The selection should succinctly summarize the features of each language and highlight the differences between them.
Names of evaluation criteria have been abbreviated in tables for compactness and readability.

\subparagraph{Comprehensiveness (Compr)}
This criterion evaluates the modelling range of the approach according to the Cameleon Framework, i.e\ , what is the most abstract modelling stage it supports.
Unless specified otherwise, an indication means that the approach supports all modelling levels \emph{below} (less abstract stages.)

\subparagraph{Expressiveness (Expr)}
This criterion expresses an \textbf{informal and subjective} judgement of the range of \textbf{concrete UI controls} supported by the approach.
The evaluation could result in three indications:
\begin{itemize}
    \item \textbf{low}: only essential controls, such as buttons, input fields and links.
    \item \textbf{medium}: more controls used in day-to-day UI development (e.g.\ selects, different input types, media elements, etc.)
    \item \textbf{high}: complex controls, such as tab containers, layout containers, decorative separators, progress indicators, etc.
\end{itemize}

\subparagraph{Support for logic (Logic)}
This criterion communicates to what extent does the approach allow for specification of the behavior of the components/whole interface.
It is divided into two subcriteria: support for \textbf{internal logic}\,\textemdash\,internal state of the UI and its transitions and support for \textbf{external logic}\,\textemdash\,integration with the functional core of the application.

Internal logic encompasses such mechanisms as component state/data binding, events/triggers, actions, expressions/conditions, or even scripting.
Support for external logic can be realized through including the description of business services or functional core methods in the specifications of presentation components.

The border between the internal and the external logic may not be clear\,\textemdash\,the external logic eventually needs to be also handled from within the interface.
Although the whole criterion could be viewed as a single spectrum, many approaches also separate these two concepts;
therefore, it's also worth judging the approaches similarly in this regard.

\subparagraph{Code generation (Gen)}
Generation of software is the ultimate promise and goal of model-based development.
Therefore, it's important for a modelling approach to support transforming a model into a functional application.
This criterion indicates the FUI technologies supported by the approach.
Most supported technologies include:
\begin{itemize}
    \item desktop applications (native widget toolkits, such as Qt with C++ or Swing with Java)
    \item HTML (plain or enhanced with JavaScript)
    \item single-page applications (SPAs) (advanced JS frameworks such as Angular, React or Vue)
    \item legacy mobile applications (apps for PDAs, utilizing WAP, Java ME, etc.)
    \item smartphone applications (for Android phones or iPhones)
\end{itemize}
Additional technologies, such as terminal or voice-enabled/conversational applications, are collected under a term \enquote{other}.

\subparagraph{Developer support (Supp)}
Nowadays, any technology is only a part of what is often called \enquote{developer experience}\,\textemdash\,adoption might be hampered when a technology is difficult to use.
This criterion judges if the approach provides additional support for modelling outside of the language definition.
The review found two ways of supporting developers: providing modelling tools or environments and definition of a development process to be used with the modelling approach.
Each of these ways is treated as a subcriterion and briefly described in the table for each group of approaches.

\subparagraph{Availability (Avail)}
The specification and documentation of a language must be available for anyone who would like to utilize it.
This criterion judges the extent to which it is possible to access any resources related to an approach.
An additional factor in this criterion is, whether the approach is a commercial contribution or not: although commercially-backed approaches can be more advanced and receive better support, their availability can be limited and volatile, guided by economic interests of the developing entity.
% Unfortunately, most approaches do not seem to be available to the broader public.
% Sometimes, they happen to be mentioned outside of scientific literature but only rarely their full specification is available to everyone.

\paragraph{Approaches based on UML}

Two papers presenting this approach have been found.

One models layout elements using UML classes~\cite{Blankenhorn2004-og}.
Interestingly, it uses UML Diagram Interchange specification (i.e.~information about how are classes positioned/colored/etc.) to convey spatial relationships between the interface elements.
Unfortunately, the approach isn't too advanced\,\textemdash\,it only supports a rudimentary set of graphical UI controls: forms, links, images, and text;
support for logic is limited only to modelling navigation between the elements.
There is also little mention of any mechanism for generating code from the model;
at most, a possibility of transforming the model into a description in another UIDL is mentioned.

The other meta-model is used in a broader approach (called MANTRA) for designing multiple interfaces for a single application core~\cite{Botterweck2011-ra}.
The work displays a higher level of maturity: in four steps, an abstract UI models is gradually adapted and transformed into a final UI\@.
Examples described in the paper demonstrate that the approach supports a standard set of controls in web, desktop and legacy mobile apps.

\subparagraph{Summary}

\begin{table}[]
    \centering
    \begin{threeparttable}[b]
        \caption{Summary of the UML meta-models reviewed.}
        \label{tab:uml-meta-models}
        \renewcommand{\tabularxcolumn}[1]{>{\normalsize}m{#1}}
        \newcolumntype{C}{>{\centering\arraybackslash}X}
        \begin{tabularx}{\textwidth}[b]{lrCC}
            % @formatter:off
            \toprule
            \multicolumn{2}{r}{}                       & \textbf{Blankenhorn (2004)}~\cite{Blankenhorn2004-og} & \textbf{Botterweck (2011)}~\cite{Botterweck2011-ra}  \\ \midrule
            \multicolumn{2}{l}{\textbf{Compr}}         & CUI                                                   & AUI                                                  \\
            \multicolumn{2}{l}{\textbf{Expr}}          & low                                                   & medium/high                                          \\
            \multirow{2}{*}{\textbf{Logic}}    & int   & navigation                                            & navigation, events                                   \\
                                               & ext   & none                                                  & integration~with~WSDL                                \\
            \multicolumn{2}{l}{\textbf{Gen}}           & none                                                  & desktop, HTML, mobile~(legacy)                       \\
            \multirow{2}{*}{\textbf{Supp}}     & tool  & ---\tnote{1}                                          & ---\tnote{1}                                         \\
                                               & proc  & none                                                  & a process for developing a~line~of~UIs               \\
            \multicolumn{2}{l}{\textbf{Avail}}         & none                                                  & none                                                 \\
            \bottomrule
            % @formatter:on
        \end{tabularx}
        \begin{tablenotes}
            \item [1] Not applicable\,\textemdash\,tooling for UML models is assumed to be widely available.
        \end{tablenotes}
    \end{threeparttable}
\end{table}

The table~\ref{tab:uml-meta-models} summarizes the information about the two approaches.
A possible advantage of using UML meta-models might be that such they are easy to work with (and e.g.~extend)\,\textemdash\,there's wide tooling support available for editing and transforming them.
Unfortunately, none of the models reviewed seems to be available anywhere.

\paragraph{Declarative approaches}

There were three papers found describing what could be named a declarative approach\,\textemdash\,one that provides a user with a DSL that can then be used to render a UI\@.

The approach presented by Hanus and Kluß~\cite{Hanus2008-hm} is implemented in Curry\,\textemdash\,a functional programming language.
Apart from describing UIs, it can be used to generate them using an additional library (e.g.\ for desktop or HTML UIs, as demonstrated in the paper.)
The library only supports a modest set of concrete (graphical) UI controls.
What is noteworthy, though, is that it is freely available\footnote{\url{https://git.ps.informatik.uni-kiel.de/curry-packages/ui}} (at the time of writing) and open-source.

Karu~\cite{Karu2013-po} proposed a DSL for UI modelling supported by a UML meta-model.
It could be argued it supports even the most abstract (T+C) level through specification of use cases and interactions (although there's no explicit modelling for concepts).
The descriptiveness and readability of the language is worth mentioning, though it seems to have come at a cost of expressiveness\,\textemdash\,the demonstration shows that generated UIs only use the simplest controls.
On the other hand, the author claims to have generated UIs in multiple modalities from the description;
unfortunately, neither examples, nor generators or the language definition itself aren't available.

Quid is a project presented by Molina~\cite{molina2019quid} and associated with a company.
It is publicly available\footnote{\url{https://quid.metadev.pro/}} (at the time of writing), together with an editor, although it is closed-source.
The contribution is a language for specifying web components.
As it is one of the most modern developments (the paper has been published in 2019), it supports code generation for multiple SPA frameworks (Angular, React, etc.)
The syntax of the language is also rather minimal and clean which aids readability.
Unfortunately, it seems the range of UI controls supported by the project in its current state is also rather narrow.

\subparagraph{Summary}

\begin{table}[]
    \centering
    \begin{threeparttable}[b]
        \caption{Summary of the declarative approaches reviewed.}
        \label{tab:declarative-approaches-review}
        \renewcommand{\tabularxcolumn}[1]{>{\normalsize}m{#1}}
        \newcolumntype{C}{>{\centering\arraybackslash}X}
        \begin{tabularx}{\textwidth}{lrCCC}
            % @formatter:off
            \toprule
            \multicolumn{2}{r}{}                      & \textbf{Hanus (2009)}~\cite{Hanus2008-hm}         & \textbf{Karu (2013)}~\cite{Karu2013-po} & \textbf{Quid (2019)}~\cite{molina2019quid} \\ \midrule
            \multicolumn{2}{l}{\textbf{Compr}}        & CUI                                               & AUI                                     & CUI                                        \\
            \multicolumn{2}{l}{\textbf{Expr}}         & low/medium                                        & low\tnote{1}                            & low/medium                                 \\
            \multirow{2}{*}{\textbf{Logic}}    & int  & state, data binding, expressions, events, scripts & events, navigation                      & state, events                              \\
                                               & ext  & programming capabilities                          & references to business services         & none                                       \\
            \multicolumn{2}{l}{\textbf{Gen}}          & desktop, HTML                                     & desktop, HTML, others                   & SPA                                        \\
            \multirow{2}{*}{\textbf{Supp}}     & tool & ---\tnote{2}                                      & none\tnote{3}                           & web editor                                 \\
                                               & proc & none                                              & none                                    & none                                       \\
            \multicolumn{2}{l}{\textbf{Avail}}        & open-source library                               & none                                    & closed-source definition~and~tool          \\
            \bottomrule
            % @formatter:on
        \end{tabularx}
        \begin{tablenotes}
            \item [1] Not enough information to decide.
            \item [2] Not applicable\,\textemdash\,existing Curry development environments should suffice.
            \item [3] The language and the underlying meta-model might be supported by existing tools.
        \end{tablenotes}
    \end{threeparttable}
\end{table}

The table~\ref{tab:declarative-approaches-review} summarizes the findings about the approaches described.
They show a lot of promise\,\textemdash\,e.g.\ support abstract modelling and logic, as well as code generation for multiple targets and modalities.
Unfortunately, each of the entries seems to have some drawbacks (small set of UI controls, unavailability, esoteric implementation) that might have prevented them from wider adoption and recognition.

\paragraph{UIDLs}

This category contains the most\,\textemdash\,seven\,\textemdash\,entries, spanning two decades of research and development.

UIML~\cite{Abrams1999-ei}, presented by Abrams et al.\ is one the earliest (1999) contributions.
It allows developers to specify an abstract representation of the interface in terms of structure, data, and events that the UI should handle using XML.
This description is then complemented with device-dependent stylesheets and mapping of UI events to application logic.
On its own, the language does not seem to support descriptions of concrete UIs;
however, it provides a mechanism of extensions \enquote{closely aligned with appliances or application domains}.
Despite its age, it is still available\,\textemdash\,it has been standardized by the OASIS group\footnote{\url{https://www.oasis-open.org/committees/tc_home.php?wg_abbrev=uiml}}.

XIML~\cite{puerta2001ximl} presented by Puerta et al.\ used to be a proprietary language focused on \enquote{representation and manipulation of interaction data}.
In the past it seemed to be a relevant contribution\,\textemdash\,other works often mention it when reviewing similar work.
However, nowadays the project is practically obsolete: the project website is not functional and the only available literature sources are rather low on details.
Therefore, it was difficult to assess the language;
its inclusion follows mostly from historic reasons.

Other approaches from that time include work by Mueller et al.~\cite{Mueller2001-un} as a part of an approach to MBUID~\cite{elwert1995Modelling} and a thesis by Pfisterer~\cite{pfistererSemantic2002}.
The first work is based on transformations of an abstract interface model into a functional artifact.
Thanks to the abstraction level, it is possible to generate UIs for modalities other than graphical.

Pfisterer's solution (dubbed SUIT) mostly focuses on describing native desktop applications on the concrete UI level.
Its distinguishing feature is a mechanism for decoupling the interface definition from functional core.
Additionally, the description provides integration for remote procedure calls.
Unfortunately, the implementation was only a prototype and supported a small set of widgets for a single toolkit.

Another major UIDL included in the review is UsiXML, presented by Limbourg et al.~\cite{limbourg2004usixml,limbourgusixml}.
The language claims to thoroughly support modelling on all stages (as outlined in the Cameleon framework.)
An additional noteworthy feature is comprehensive support for transforming the models between stages through graph transformations.
It seems to have been a mature and complex project, although now it does not seem to have a lot of activity;
its website\footnote{\url{http://www.usixml.org/en/home.html?IDC=221}} is still available but does not contain any useful resources (such as the language specification or related tools).

A similar language is MARIA~\cite{Paterno2009-nj} (a successor to TERESA~\cite{Mori2004-sr}\,\textemdash\,a modelling tool and an accompanying language).
While it didn't support modelling on the tasks-and-concepts level, it was similarly comprehensive in other aspects, such as transformations and tool support.
An additional feature worth mentioning was direct integration with business services described in WSDL\,\textemdash\,the language was dedicated for service-oriented applications.
Unfortunately, it's also unavailable these days\,\textemdash\,no information about the language can be found beyond academic publications and a Wikipedia entry\footnote{\url{https://en.wikipedia.org/w/index.php?title=MARIA_XML&oldid=1104861380}}.

The last (and the newest) entry in this category is OpenUIDL~\cite{moldovan2020open}, authored by Moldovan et al.\,\textemdash\,developers of the teleportHQ platform\footnote{\url{https://teleporthq.io/}}.
It differs from all the other entries by using JSON and TypeScript (instead of XML) to define the description and its schema.
%Because of the definition of syntax, it lies a bit closer to the group of domain-specific languages;
%here, it's still classified as a UIDL due to the similar role of JSON and XML as data transport formats.
Additionally, the approach, as well as the whole ecosystem is available to the general public through GitHub.
Although the paper claims that the language should be able to support multiple modalities, judging by code generators provided (as well as the company's website), the language's main focus seems to be on describing and generating interfaces for Web applications.

\begin{table}[]
    \centering
    \begin{threeparttable}[b]
        \caption{Table summarizing the UIDLs reviewed.}
        \label{tab:uidls-review}
        \renewcommand{\tabularxcolumn}[1]{>{\normalsize}m{#1}}
        \newcolumntype{C}{>{\small\centering\arraybackslash}X}
        \begin{tabularx}{\textwidth}{lrCCCC}
            % @formatter:off
            \toprule
            \multicolumn{2}{r}{}                      & \textbf{UIML (1999)}~\cite{Abrams1999-ei} & \textbf{Mueller (2001)}~\cite{Mueller2001-un} & \textbf{XIML (2001)}~\cite{puerta2001ximl} & \textbf{SUIT (2002)}~\cite{pfistererSemantic2002} \\ \midrule
            \multicolumn{2}{l}{\textbf{Compr}}        & AUI\tnote{1}                              & AUI                                           & T+C                                        & CUI                                               \\
            \multicolumn{2}{l}{\textbf{Expr}}         & low\tnote{1}                              & medium/high                                   & medium/high\tnote{3}                       & medium                                            \\
            \multirow{2}{*}{\textbf{Logic}}    & int  & events                                    & none\tnote{3}                                 & none\tnote{3}                              & data binding, expressions, events                 \\
                                               & ext  & UI-backend mappings                       & none\tnote{3}                                 & none\tnote{3}                              & support for remote logic                          \\
            \multicolumn{2}{l}{\textbf{Gen}}          & none\tnote{1}                             & desktop, HTML, mobile~(legacy), others        & none\tnote{3}                              & desktop                                           \\
            \multirow{2}{*}{\textbf{Supp}}     & tool & none                                      & none                                          & none\tnote{3}                              & none                                              \\
                                               & proc & none                                      & part of a broader MBUID approach              & none\tnote{3}                              & none                                              \\
            \multicolumn{2}{l}{\textbf{Avail}}        & standardized by~OASIS                     & none                                          & none                                       & none                                              \\
            \bottomrule
            \end{tabularx}
        \begin{tabularx}{\textwidth}{lrCCC}
            \toprule
            \multicolumn{2}{r}{}                      & \textbf{UsiXML (2004)}~\cite{limbourgusixml,limbourg2004usixml} & \textbf{MARIA (2009)}~\cite{Paterno2009-nj} & \textbf{OpenUIDL (2020)}~\cite{moldovan2020open} \\ \midrule
            \multicolumn{2}{l}{\textbf{Compr}}        & T+C                                                             & AUI                                         & AUI\tnote{2}                                     \\
            \multicolumn{2}{l}{\textbf{Expr}}         & unknown\tnote{3}                                                & unknown\tnote{3}                            & medium                                           \\
            \multirow{2}{*}{\textbf{Logic}}    & int  & events, actions, navigation                                     & events, scripts                             & state, events, expressions, navigation           \\
                                               & ext  & none\tnote{3}                                                   & integration~with~WSDL                       & none\tnote{3}                                    \\
            \multicolumn{2}{l}{\textbf{Gen}}          & HTML, others                                                    & desktop, HTML, mobile~(legacy)              & SPA                                              \\
            \multirow{2}{*}{\textbf{Supp}}     & tool & multiple, various tools                                         & tool for editing models                     & web editor                                       \\
                                               & proc & none                                                            & an approach to~\enquote{migratory~UIs}      & SPEM disciplines for a development process       \\
            \multicolumn{2}{l}{\textbf{Avail}}        & scarce                                                          & scarce                                      & open-source tool and definition                  \\
            \bottomrule
            % @formatter:on
        \end{tabularx}
        \begin{tablenotes}
            \item[1] CUI support facilitated through language extensions;
                     other aspects also dependent on language extensions.
            \item[2] The description of the language in the paper suggests support for the T+C level, but judging by the mechanisms described, support for AUIs is more likely.
            \item[3] Not enough information to decide.
        \end{tablenotes}
    \end{threeparttable}
\end{table}

\subparagraph{Summary}
The table~\ref{tab:uidls-review} summarizes the information about the UIDLs reviewed.

This area of MBUID is the most studied and has the most papers from all four categories.
However, practically none of the contributions seems to have stayed relevant until this day.
Even though some of the languages offered sophisticated support for modelling from the most abstract description to the final interface, they do not seem to have gained wider recognition and are not longer developed.

\paragraph{Approaches based on ontologies}

Two ontological approaches have been found during the review.

The paper from 2013 by Paulheim and Probst~\cite{paulheim_ui2ont_2013} presents an ontology (UI$^{2}$Ont) developed on the basis of most relevant contemporary UIDLs.
This approach made it possible for the ontology to cover a wide range of interaction possibilities.
The authors divided the description elements into four parts on two axes: top-/detail level and design-time/run-time description.
Additionally, the ontology has reportedly been used in a case study of integration of multiple user interfaces;
however, the realization has not been described in detail.

The ontology described in the other paper~\cite{wysota_semantic_2015} approaches the problem more traditionally and focuses on describing UIs in terms of concrete graphical controls.
The range of controls supported by the ontology seems rather narrow, judging by the examples shown in the paper.
There is only a brief mention of a mechanism of notification and actions.
An example of a UI generated based on an ontological description was provided, although without a description how it was obtained.

\subparagraph{Summary}

\begin{table}[]
    \centering
        \begin{threeparttable}[b]
            \caption{Table summarizing the ontologies reviewed.}
            \label{tab:ontologies-review}
            \renewcommand{\tabularxcolumn}[1]{>{\normalsize}m{#1}}
            \newcolumntype{C}{>{\centering\arraybackslash}X}
            \begin{tabularx}{0.8\textwidth}[b]{lrCC}
                % @formatter:off
                \toprule
                \multicolumn{2}{r}{}                      & \textbf{UI$^{2}$Ont (2013)}~\cite{paulheim_ui2ont_2013} & \textbf{Wysota (2015)}~\cite{wysota_semantic_2015} \\ \midrule
                \multicolumn{2}{l}{\textbf{Compr}}        & T+C\tnote{1}                                            & CUI                                                \\
                \multicolumn{2}{l}{\textbf{Expr}}         & medium/high                                             & low                                                \\
                \multirow{2}{*}{\textbf{Logic}}    & int  & navigation, events\tnote{1}                             & events\tnote{1}                                    \\
                                                   & ext  & none                                                    & none                                               \\
                \multicolumn{2}{l}{\textbf{Gen}}          & none                                                    & desktop                                            \\
                \multirow{2}{*}{\textbf{Supp}}     & tool & ---\tnote{2}                                            & ---\tnote{2}                                       \\
                                                   & proc & none                                                    & none                                               \\
                \multicolumn{2}{l}{\textbf{Avail}}        & none                                                    & none                                               \\
                \bottomrule
                % @formatter:on
            \end{tabularx}
            \begin{tablenotes}
                \item [1] Not enough information to decide.
                \item [2] Not applicable\,\textemdash\,there should exist enough tooling support for working with ontologies.
            \end{tablenotes}
        \end{threeparttable}
\end{table}

The table~\ref{tab:ontologies-review} summarizes the ontologies reviewed.
They could be viewed as the most exotic approach to modelling UIs, as evidenced by the fact that there is only a single contribution in the area that has some practical potential.
Nevertheless, the UI$^{2}$Ont ontology looks like a mature and comprehensive work, building on experiences from languages coming before it.

The position paper related to the UI$^{2}$Ont ontology~\cite{paulheim_formal_2011} describes a perspective on the relationship between UI description languages and UI ontologies, which might explain lack of interest in the latter approach:
these are simply two types of models with different assumptions and goals.
UIDLs aim for efficiency of modelling, while ontologies focus on comprehensiveness and precision.
Ontologies won't replace UIDLs; however, they might be a valuable enhancement for them (and vice versa), as was the case with the UI$^{2}$Ont ontology\,\textemdash\,the ontology itself was developed on the basis of previously existing UIDLs.
Conversly, such an ontology could help validate new or existing languages.
