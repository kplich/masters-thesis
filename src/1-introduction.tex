\chapter{Introduction}\label{ch:introduction}

\section{Overview of model-based user interface development}\label{sec:user-interfaces-are-important}
Computing technologies are ubiquitous nowadays: even though devices such as computers and phones have increasingly become more capable, sophisticated, and interconnected from decade to decade, they have nevertheless become the daily reality of billions of people around the world.
That is in large part thanks to user interfaces (especially graphical ones) which present the functionality of the software in approachable terms (e.g., metaphors of a desktop or folder, which are still relevant to this day);
they make the software available to everyone, regardless of their background, not only to specialists capable of dealing with low-level technical minutiae.
It is not surprising, then, that design, implementation, and maintenance of UI are one of the main points of interest during the development of software products~\cite{Anderson2010} -- their usability can be a deciding factor in their commercial success or failure~\cite{Offutt2002}.

Development of UIs has never been easy -- research shows that related processes take up roughly half of the time devoted to developing the whole product~\cite{Myers1992}.
Initially, the reason lay in technical difficulties~\cite{Six1991};
however, over time, the challenge has taken on a new dimension:
the number, diversity, and connectedness of devices on the market have risen exponentially~\cite{Cisco2020}.
Such an explosion of complexity has made it ever so harder to deliver a consistent and satisfying user experience to users.
Together with the maturation of computing technologies, methods for the systematic development of UIs have also been devised to simplify and accelerate the process while, at the same time, reducing costs and mistakes.

The process has started with user interface management systems (UIMSs) -- tools for the \enquote{development and management of the interaction in an application domain across varying devices, interaction techniques, and styles.}~\cite{Betts1987}
However, the software in the category did not live up to this promise -- it was difficult to use and not portable or expressive enough -- as such, it did not gain much recognition in the industry~\cite{Myers1987}.

The need for a more general and systematic approach to development was not unique to the area of UI development;
the whole discipline of software engineering desired to move away from platform-specific complexities of programming towards a more abstract and rigorous process.
The domain also saw its first attempts to alleviate these difficulties with computer-aided software engineering (CASE) approaches.
They had aims similar to those of UIMSs -- abstraction from the platform, effortless analysis, and automatic implementation -- and suffered a similar fate -- the software could not handle the intricacies of real-world software.

Since then, development has become easier, with object-oriented languages and frameworks that perform a substantial part of the \enquote{dirty work.}
Nevertheless, software development is still an involved, often manual process of translating requirements into design decisions and then into code~\cite{Schmidt2006}.
Recognizing these everlasting difficulties and attempting to learn from the failures of CASE, a new paradigm -- \textbf{model-driven engineering/development (MDE/MDD)} -- has emerged.
Its basic principle is that \enquote{everything is a model}~\cite{bezivin2004search} -- models are first-class entities in software development, not just means to document or design.
Through the  use of metamodels (models defining models), platforms (specification of an execution environment for a set of models), and model transformations (processes of converting a model to another model or source code), the approach sets out to raise the abstraction level in programming and allow partial or even complete automation of software development processes~\cite{mellor2004mda}.

One of the most prominent examples of a model-driven engineering approach appeared in the form of \textbf{Model-Driven Architecture (MDA)}, elaborated by Object Management Group in 2000~\cite{richard_soley_model_2000} and with the latest update published in 2014~\cite{mda_2014}.
In support of the paradigm, MDA defines (among others) MDD concepts mentioned before, as well as a set of standards for modeling, the most prominent being the Meta Object Facility (MOF)~\furl{https://www.omg.org/mof/} and the Unified Modelling Language (UML)~\furl{http://www.uml.org/}.
The main feature of the approach is leveraging transformations from so-called \textbf{platform-independent models (PIMs)} to \textbf{platform-specific models (PSMs)}.
The former, as the name suggests, do not depend on platform details and are more aligned with the business and analytical environment;
the latter contain more implementation details and are closer to a specific technology.

Since then, the approach has been translated to the domain of user interface development as \textbf{model-based user interface development (MBUID)}~\cite{Puerta1994}.
There have been many achievements in the area â€“ the methods progressed from simply generating a UI for a single device to managing the diversity and complexity of interfaces, handling different platforms, devices, interaction modalities, user states, and usage contexts~\cite{Meixner2011}.
In all of them, the model is a central artifact in the development process;
so much so that it has received a particular name in the domain of MBUID -- a \textbf{user interface description language (UIDL)}~\cite{guerrero_garcia_theoretical_2009}.
Although the name suggests a textual description, the language in question could be any high-level, formal description of user interfaces (if not textual, it is usually expressed as a UML metamodel).
UIDLs can also be viewed as a part of a particular case of \textbf{domain-specific languages (DSLs)} -- languages designed to effectively model a specific domain (UI description, in this case);
through such high-level representation, the MBUID and MDE reach their goal of modeling closer to the problem domain.

As the maturity of solutions increases, it is expected that model-based approaches will become model-driven, i.e., fully automated and integrated with other parts of the development process in the spirit of model-driven development~\cite{Ruiz2018}.
Additionally, a paradigm similar to model-driven development has emerged recently from the business side of systems development in the form of \emph{no-code} or \emph{low-code development}~\cite{Rymer2019}.
Although it is viewed as an exercise in rebranding MDE without any underlying technical innovation, the intensive business support may serve as a vehicle for promoting concepts aligned with MDE~\cite{Bock2021}.

\section{The Cameleon Reference Framework}\label{sec:the-cameleon-reference-framework}

The Cameleon Reference Framework (CRF)~\cite{calvary_cameleon_framework_2002, calvary_cameleon_glossary_2002} represents a significant development in the field of model-based UI development, comparable in scale to the MDA\@.
It defines many aspects of the area and organizes them into a framework for evaluating tools and approaches related to the discipline.
The most important contribution of the project is the definition of four levels of abstraction in UI development:
\begin{samepage}
\begin{itemize}
    \item \textbf{Tasks and concepts (T+C)}: on this level, the UI is viewed only from a \textbf{functional and conceptual perspective}; no thought is given to the specifics of the interaction.
    \item \textbf{Abstract UI (AUI)}: on this level, the UI is structured \textbf{independently of the modality of interaction} -- it is not yet known if it will be a graphical, textual, or voice UI (to name a few examples).
    \item \textbf{Concrete UI (CUI)}: on this level, the modality of the UI is known, and the specification is only \textbf{independent of the platform}. For example, the definition assumes a graphical UI and specifies a text input; however, it is not yet decided what technology will be used to realize it.
    \item \textbf{Final UI (FUI)}: on this level, the executable UI, written in a \textbf{particular technology}, is generated.
\end{itemize}
\end{samepage}
Models at these stages can be related through transformations: \emph{abstraction}, \emph{reification}, and \emph{translation}.
For example, a model at the AUI stage can be \emph{abstracted} from a model at the CUI stage -- in the process, modality-specific information is lost (cannot be expressed) at this stage.
Conversely, a model at the AUI stage results from \emph{reifying} of the T+C stage (adding more information about how the UI should be structured) -- one can think of the two transformations as inverses.

Step-by-step reification of models is a primary way of developing a user interface based on models.
Abstraction can be used to reverse engineer models from an existing UI\@.
\emph{Translation} -- a transformation between models at the same level (e.g., translation of a graphical CUI model to a voice CUI model) -- complements the picture.

\section{Expressiveness as a crucial model quality in MBUID}\label{sec:model-quality-in-mbuid}
Naturally, to achieve the objectives of model-based UI development, the models must satisfy certain properties.
Hailpern and Tarr discuss this problem in the context of model-driven development in general: they describe UML as an example of a model (or a set of models) that might not satisfy the needs of approaches in the domain~\cite{Hailpern2006}.
In that case, the authors point to the complexity and insufficient semantics as language deficits that limit its expressive capacity and potential for automation and thus discourage its wider adoption.

Vanderdonckt also identifies model quality as one of the challenges in the field of MBUID, naming semantics and syntactic and stylistic rigor as valuable features of a model~\cite{Vanderdonckt2008}.
These features help ensure that the model satisfies desirable properties, such as completeness, consistency, correction, expressiveness, and conciseness.
In the paper, expressiveness is defined as \enquote{[the] ability of a model to express via an abstraction \textbf{any} [real-world] \textbf{aspect of interest}.}
The flexibility of modelling is essential, as it helps better satisfy application requirements;
its lack can force developers to modify generated code manually~\cite{Pederiva2007}.
As suggested by Aquino et al.~\cite{Aquino2010}, adding another model could solve this problem;
unfortunately, this solution leads to a different problem and challenge in MBUID: the risk of the proliferation of models.
Ideally, the UI model should allow flexibility without any excessive constructs.

\section{Goal and scope of the thesis}\label{sec:goal-and-scope}

Various reviews show that UI representations are, for the most part, not yet flexible enough for most applications~\cite{Ruiz2018, Souchon2003}.
However, they do not provide a detailed account of how they evaluate the expressiveness of UI models.
Therefore, this thesis aims to investigate this aspect of UI representations more comprehensively and report the results.
Expressiveness is understood as the ability of a model to capture information relevant to generating the final user interface.

% TODO: serio, chyba tu sie przyda wiecej tekstu, chociaz akapit
% TODO: context is development
% TODO: abstract not in the sense of Cameleon Reference Framework, but abstract in the sense of "level higher than implementation"

The goal of the thesis can be formulated in terms of the following research questions:
\begin{itemize}
    \item \textbf{RQ1}: What abstract UI representations exist?
    \item \textbf{RQ2}: How do these representations allow for influencing the final UI? What aspects of UI programming are necessary to create one suitable for development?
    \item \textbf{RQ3}: To what extent can the studied representations be considered expressive? What is their effectiveness in development tasks?
\end{itemize}

A systematic literature review was conducted to answer RQ1 -- Chapter~\ref{ch:literature-review} presents its results.
Chapter~\ref{ch:research-methodology} provides the answer to RQ2 by describing the research methodology applied;
Chapter~\ref{ch:results-and-discussion} presents an analysis of the obtained results, thus answering RQ3.
Chapter~\ref{ch:summary} summarizes the thesis.
